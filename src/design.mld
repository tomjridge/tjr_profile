{1 Requirements }

- Low overhead
- Uses TSC (focus on Linux with TSC available; ignore jsoo)
- Can substitute a "do nothing" implementation, for jsoo and elsewhere
- Default implementation is "do nothing" except that the initialization steps (declaring
  timers) are executed and have an effect
  - and can call init at runtime to substitute a real TSC interface
  - at which point, during execution the timing info is recorded (whereas with the dummy
    impl this info would be thrown away)

{1 Simple Timer Interface, for benchmarking an API for example}

{[
type timer
type name = string

(** At module initialization time *)
val create_timer: ?print_at_exit:bool -> name -> timer
val create_timer: name -> timer

(** At runtime *)
val start_timer: timer -> unit
val stop_timer: timer -> unit
val timer_total: timer -> int
val timer_count: timer -> int

val now: (unit -> int) ref (** Clock reference; can be altered by linking a profile.tsc lib *)

val time: timer:timer -> (unit -> 'a) -> 'a

]}

Typical usage:

{[
let time ~timer (f:unit->'a) = 
  start_timer timer;
  let r = f () in
  stop_timer timer;
  r
]}

Perhaps we want an even simpler way to do this without declaring a timer upfront? but
typically f will be parameterized, so we need some link to a timer outside where we 


{1 Waypoint interface}

This interface allows tracking time between code points ("waypoints"), where the waypoints
are typically points in the code tree:

{[
if x then
  (* waypoint a *)
  mark a1;
  do_something()
  mark a2;
  if y then 
    mark b1
    do_something_else();
    mark b2
  else
    mark c1
    do_something_more();
    mark c2
]}

We associate the waypoint strings with ints, then record a trace of int pairs, where the
pair is [(waypoint,time)]. This takes two ints, and we write the trace into a potentially
huge mmap'ed file (or maybe just a large array in memory; the file has the advantage that
we don't keep on traversing it during OCaml GC). When the program finishes, we analyse
this file to work out, for each [(pt1,pt2)] transition, the count and the total time. This
computation may be expensive, but it takes place after everything else, so doesn't disturb
the timings.

Typically we want to do this per-file, with something like 

{[
let mark,[a1;a2;b1;b2;c1;c2] = make_waypts ~name ["a1";"a2";"b1";"b2";"c1";"c2"]
]}
. Assume n waypts in the file.

Waypts are guaranteed to be consecutive ints; maybe it is also clear from the intf that they are ints.

Then this should set up a 2d array n*n (arr[a][b] is from waypt a to waypt b), with entries {count;total_time}

Waypts can be any int >0

We want minimal impact on the file where we use the waypts. So the above seems
reasonable. This gets us the mark and the waypts.

Interface:

{[

(** A collection of waypoints *)
type waypoint (* = int *)

val make_waypts : __FILE__:string -> string list -> (waypt -> unit) * waypt list

val dummy_make_waypts : (same sig)

val print_at_exit: boolean ref (** whether to print waypts on exit; default false *)

]}

Maybe we can turn off waypts altogether in the library? Not just the printing, but also
the overhead of marking. Perhaps by default it is not enabled unless we set the envvar
TJR_PROFILE?

Locally we can then enable/disable with:

{[
let mark,[a1;a2;b1;b2;c1;c2] = (if enabled then make_waypts else make_waypts_noop) ~name
["a1";"a2";"b1";"b2";"c1";"c2"]

(* or maybe *)

let mark,[a1;a2;b1;b2;c1;c2] = make_waypts ~name ["a1";"a2";"b1";"b2";"c1";"c2"]
let mark _ = ()
(* and in this case we want to avoid printing the summary at exit *)
]}


Maybe we can provide a config file to specify which files to enable waypts for?

We can also have a library tjr_profile.config which provides now and is controller by 


{1 Printing table at end}

Perhaps use printbox


{1 Problems with current impl} 

- tjr_profile.small is not really doing much; prefer a single publicly-visible intf
- config via changing the config.ml file is best performance-wise, but perhaps a bit ugly
- separating intern and mark probably not as nice as the above
- depending on -1*pt is a bit bad in terms of future evolution of intf; 
- impl uses a huge array which imposes start up time delay
- pretty printing code is a bit horrible; prefer some kind of csv output
- too many files
